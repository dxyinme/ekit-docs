# 架构设计

## 总体设计

![img.png](./img/architecture.png)

目前来看，整体上可以分成几个核心部分：
- 管理 API。它是用于任务自身的管理，例如创建、编辑或者修改之类的。我们会基于这个管理 API 提供一个管理后台，但是同时用户也可以构建自己的管理后台，或者直接在代码里面编程式地创建任务或者管理任务。所以这个 API 强调的是简单、通用；
- 管理后台：基于管理 API 构建的一个可视化管理后台。该管理后台能够暴露接口，以允许用户接入 SSO 和权限控制等必备模块。与此同时，该管理后台与用户自己写的管理后台应该是具有平等地位的，也就是意味着管理 API 的每一个 API 都是通用的，不能针对这个默认的管理后台做任何假设；
- 调度核心：它需要解决一下问题：
  - 广播、组播和单播调度的问题
  - 负载均衡问题
  - 重试
  - 任务编排：即在前置任务成功之后才能调用后续任务。也要考虑前置任务有必选、可选的区别；
  - 资源控制：能够控制在特性范围内的资源消耗，例如某个组，某个部门或者某个项目内部的资源消耗；
- 监控和告警：提供通用的 API，以允许用户接入各种监控。prometheus 和 opentelemetry 作为默认的实现，和用户的自定义实现地位是平等的，即 API 不能针对默认实现做任何假设。告警也是类似。本质上可以认为我们需要在整个系统里面设计一整套的埋点监控的方案；
- 执行者 API：执行者代表的是一个可以被调度的实体。我们需要考虑以下场景：
  - 任务是一个 RPC 服务：在这种情况下要考虑适配不同的 RPC 协议
  - 任务是一个 HTTP 接口：需要设计统一的 HTTP 服务定义
  - 任务是一个云原生任务，需要创建一个新的容器，运行之后就退出
- 任务存储：它一方面需要存储任务规格说明，另一方面需要存储任务调度信息。调度信息包含两个部分：即将被调度的信息，以及历史调度信息。任务存储本身是一个抽象层，我们并不局限于使用 mysql 做存储。我们需要定义出一套接入规则，允许用户提供不同的存储。同样地，我们默认提供的实现也不能具有任何的特殊的地位。在提供一个实现的时候，需要考虑以下问题：
  - 在创建的任务数量及其庞大的情况，任务该如何存储以及被快速检索

此外，出于安全性的考虑。任何涉及网络调用过程的组件之间的通信，必须设计完整的身份认证和权限控制机制。包括：
- 和管理 API 的交互
- 和执行 API 的交互

## 集群模式选择

这里我们讨论的是调度集群的集群模式。大体上来说，可以分成对等模式和主从模式：
- 对等模式
- 主从模式
- 混合模式：整体是一个对等模式，但是每一个节点也是主从模式

### 对等模式

对等模式的基本形态就是每一个节点都是平等的，可以独立的调度任务而不必与其它节点交互。对等集群要解决的第一个问题是如何分配任务。

分配任务的难点在于两方面：
- 难以确定一个节点能调度多少任务
- 调度不同任务所需要的资源都是不一样的

目前业界的做法有两种：
- 第一种是节点自己去抢。这种机制也是有问题的：
  - 节点需要考虑自己究竟有没有容量去处理更加多的任务；
  - 需要一个再均衡负载的机制。当某个节点发现自己负担了很多任务之后，它可以考虑放弃一部分，或者直接将一部分任务转交给别人。这种转交可以主动的，也可以是被动的。被动的则是意味着采用窃取方案；
- 第二种则是通过用户指定。用户指定可以是在启动的时候通过配置文件启动，也可以是通过配置中心指定，或者是通过管理后台来指定；

归根结底是对等节点难以做到负载均衡，包括难以在负载不均衡的时候进行再分片。

### 主从模式
主从模式并不是说只有主节点来执行调度。主从模式核心是依靠主节点来进行分片，即为每一个节点分配任务。在这个过程中，它需要做到尽可能使所有的节点负载均衡。

进一步说，主节点还肩负着再负载均衡的任务。即如果主节点本身发现从节点上的任务负载不再均衡，那么就需要选择合适的节点，将负载分出去，即再分片。

主从模式有几个问题：
- 脑裂问题：这个问题众所周知，这意味着会有多个主节点尝试着进行分片
- 主从选举问题：在主节点崩溃之后，需要选举出来一个从节点接替主节点。在这种情况下，从节点本身运行了一些任务，它在被提升成为主节点之后，要不要继续调度原本分配的任务，如果不调度，就需要执行再分片的过程。涉及到主从选举，又会涉及另外一个问题，就是主从选举怎么选

进一步地，我们可以考虑所谓的哨兵模式。

哨兵模式可以看做是主从模式的变种。哨兵模式的核心是维护两个集群，一个哨兵集群，一个调度节点集群。哨兵集群时刻监控调度节点的运行情况，并且在一个节点崩溃之后要及时把任务分配给其他节点。哨兵集群自己也有多个节点，可以是对等也可以是主从。

不过这种模式有一点脱裤子放屁的感觉，因为在分布式任务这个系统里面，用不上这么复杂的结构。

## 基本概念

### 调度集群、执行（任务）集群、调度节点和执行节点

在我们的整个设计里面，有很多组件本身就是一个集群：
- 调度集群是指调度核心部署的集群，它的每一个节点就是调度节点；
- 执行（任务）集群：执行集群或者任务集群，它是指执行任务的集群。一般来说就是用户的业务集群，调度集群需要在所有的候选执行节点里面筛选出部分来执行任务

### 注册任务

注册一个任务可以通过多种途径：
- 通过管理后台注册。在注册的时候需要指定任务的
  - 唯一标识符
  - 调度策略（包含负载均衡策略）
  - 前置任务
  - 可运行实例
- 通过编程接口。例如用户在自己的代码里面通过的编程的形式注册一个任务，它又分成两种形态：
  - 将自身注册为一个任务
  - 创建并且注册一个新任务，自身只是一个创建者

### 调度策略
调度策略是一个抽象，它包含：
- 重试机制：包含重试次数和退避算法，也要进一步考虑在某一次调用失败之后是否需要更换节点的问题
- 负载均衡策略：在所有可执行该任务的节点里面，选择一个合适的节点。类似地，这里也可以进一步考虑路由策略
- 广播、组播和单播：对于大多数任务来说，只需要在一个候选节点上运行。但是对于对实时性或者可用性要求比较高的任务来说，它们会希望在所有的节点上运行。还有一些任务，可能只能运行在特定的一些候选节点上

### 候选节点
可执行某个任务的节点，被称为该任务的候选节点。候选节点可以通过以下几个方式执行（或者发现）：
- 引入类似服务发现机制，根据任务的唯一标识符来查找候选节点
- 直接指定：用户在注册任务的时候直接指定候选节点的域名或者 IP + 端口
- 创建容器运行：这一类任务并没有候选节点，而是调度核心根据任务的配置实时创建容器，在执行完毕之后，回收资源

### 任务编排

任务之间存在一定的依赖关系。调度核心在调度任务的时候，需要检查该任务的所有前置条件是否满足，满足之后才能被调度。类似地，当一个任务结束之后，要考虑调度后置任务。

### 远程插件
所有的任务，都允许在调度的周期内注册一些远程插件。这些插件和调度核心将通过 gRPC 或者 http 协议进行通信。

举个例子来说，在执行负载均衡筛选节点的时候，如果用户希望动态筛选节点，那么可以调用用户注册的负载均衡策略插件。调度核心根据返回的结果进行调度


### 任务规格说明

或者说，任务配置。任务的编排、调度都是通过任务规格说明来配置的。本质上，任务的注册就是一个生成任务规格说明的过程。

因此调度核心重要职责就是解释这一份任务规格说明。