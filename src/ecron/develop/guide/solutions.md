# 行业方案

如果你对我们是从什么方面调研的，可以参考这个：
- [2022.12.15 会议纪要](https://github.com/gotomicro/ecron/discussions/1)

## Kubernetes

k8s 的调研部分由 @henrysworld 完成。

### 分析

k8s 整体设计自然是十分优秀的，其中值得我们重点关注和学习的点：
- 声明式设计
- Job 和 CronJob 的分离

#### 声明式设计

这算是 k8s 一贯以来的设计风格。在我们架构设计里面也是打算借鉴这这种设计思路。即所有的任务都会有一份任务规格说明，而所谓的调度引擎就是根据这份规格说明来执行调度。所以总体上来说，我们的设计可以称为配置驱动，或者 spec driven。

#### Job 和 CronJob 分离
理论上来说，在 k8s 里面的 Job 概念，应该只能算是 CronJob 的一种特殊形态。

我们可以设想，假如说我们有一个定时任务是每天 00:30:00 执行一次。那么所谓的一次性任务就是只执行一次的定时任务；而实时任务则是只执行一次的，恰好立刻执行的定时任务。

所以从设计上来说，Job 和 CronJob 的区分是无所谓的，完全可以将它们纳入统一抽象之下。而两个参数 completions 和 parallelism CronJob 一样可以使用。completions 也就是我们调度策略里面谈及的应该在多少个实例上调度，而 parallelism 则可以理解为该任务允许并行调度多少个实例。

> 猜想是因为 k8s 本身不是一个纯粹的任务调度框架，所以受制于其他诸如容器编排的功能，而不得不引入这种区分

#### 任务信息存储

令人惊讶的是，k8s 的所有配置，不管是 Job 还是 CronJob，都是利用 etcd 来存储的。我们可以考虑将 etcd 作为存储引擎的一种实现。因此 k8s 如何在 etcd 上组织自己的 Job 和 CronJob 的配置，就很值得关注。

### 待确认的点
- k8s 的队列是如何设计的：
  - k8s 什么情况下会往里面加入任务？例如说，我有一个每日 00:30:00 执行的任务，这个任务是每天（例如 00:15:00）加入一次，然后执行完，还是使用了什么其它策略？比如说，每天执行一次这一类的任务，k8s 总不可能一次性生成从 2023 年到 2123 年的所有调度信息
  - 在删除或者修改任务的情况下，k8s 怎么快速定位到队列中相关的任务？注意 k8s 是采用遍历，还是接近 map 之类的数据结构 
  - 队列的容量，即它最多允许放置多少个任务？
  - 队列是否有分组之类的机制？例如说，近一分钟内就要被调度的任务在一个组里面；近半小时的在另外一个组里。又或者说整个 k8s 集群只有一个队列，还是说逻辑上只有一个队列，但是内部有很多子队列？
- k8s 的时间精度问题。例如说我们预期在 00:30:00 执行，那么它可能在什么精度的时间范围内调度到这个任务？例如说秒级精度就是会在 00:29:59 - 00:30:01 这个时间段内调度到
- k8s 的任务编排能否解决前置任务这种场景？
- k8s 的容错机制：
  - 任务运行时间过长会如何？
  - 任务失败了，怎么重试？重试一直失败会如何？
  - 如果一个任务占据了很多资源，会不会影响别的任务调度？
  - 如果一个任务是半小时运行一次，但是某一次运行超过了半小时，会造成时间窗口重叠吗？即这个时候会同时有两个同样的任务运行吗？又或者说，当我们说半个小时运行一次的时候，半小时是从上一次任务结束之后开始计时，还是从上一次任务开始运行的时候就开始计时？
- k8s 队列相关的 API（只需要接口）：从队列中增删改查任务的接口，重中之重是调度器怎么从队列里面拿到任务
- Job 和 CronJob 的完整配置：即所有允许用户配置的配置项，以及它们的含义。