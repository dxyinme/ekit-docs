# 队列

我们在 ekit 里面提供了几种队列：
- 线程安全与非线程安全的
- 阻塞与非阻塞的
- 有界与无界的

总体上来说，队列使用起来很简单，但是如果没有控制好一些参数的话，可能会遇到一些意想不到的情况。

我们建议你在选用队列的时候，一定要阅读我们的注意事项以及特定队列实现的注意事项。不过如果你的应用本身并发数不高，数据量也不大的话，那么就可以随便了。

## 队列实现

### 并发非阻塞队列
并发非阻塞队列我们只提供了
#### 无锁实现 ConcurrentLinkedQueue

### 并发阻塞队列
并发
#### 基于切片的实现 ConcurrentArrayBlockingQueue
#### 基于链表的实现 ConcurrentLinkedBlockingQueue
#### 选型

### 优先级队列
#### 并发非阻塞优先级队列
### 延时队列 DelayQueue

## 注意事项
### 阻塞超时控制精确性问题
我们不提供任何关于时间精确度的保证。举个例子，如果你在操作并发队列的时候，设置的阻塞时间是 100ms，那么我们不能保证它一定会在 100ms 的时候准确返回一个超时错误。但是我们可以保证，不会在 100ms **内**返回超时错误。即如果你收到了超时错误，那么必然已经过去了至少 100ms。

> 当然，如果你考虑时钟准确性的问题，那么实际上也有可能是 100ms 内就返回了超时错误。

阻塞超时控制的精度问题源自很多方面：
- 时钟准确度问题。如果你的超时控制是基于现实时间的话，那么会有问题。但是如果你的超时是基于同一个进程的（或者同一台机器上），那么相对来说肯定没问题——毕竟不同 goroutine 之间使用的是同一个时钟；
- 阻塞未能被唤醒，或者被唤醒本身就存在时间误差。我们大量依赖了 Go 的 time 包。但是这个 time 包本身就不是很精确。此外，我们大量依赖 channel 来做同步，例如在出队的时候通知入队被阻塞的 goroutine，而从信号发出来，到 goroutine 被唤醒，也是一个需要时间的过程；
- goroutine 未能被及时调度：如果当下 CPU 资源（按照 GMP 调度的说法，应该是抢不到 P）紧张，那么即便一个 goroutine 本身是可以被调度的，但是真的调度到它，可能已经过去了很长时间；
- Go select 特性：我们在队列里面大量使用了 select-case 来同时监听超时和数据操作通知（入队或者出队）。举例来说，我们在出队的时候，会同时监听 context.Context 的 Done 信号（即超时或者被取消）和入队新元素的信号，如果在某个时刻，恰好有一个元素入队，并且触发超时，那么 Go select 本身是随机挑选一个 case 分支进去执行。这个分支可能是出队，也可能就是直接返回超时错误；
- Go 垃圾回收：Go 在触发垃圾回收的时候，会在两个方面影响超时的效果。第一个是 STW（stop the world），假设还剩下 1ms 就超时了，此时触发了 STW 10ms，那么你收到超时的时候就比预期的晚了 9ms；另外一个则是在垃圾回收的时候，相当多的 CPU 资源被拿去处理垃圾回收，因此会导致 goroutine 未能被及时调度；

### 和 channel 的对比
首先，你应该永远优先使用 channel，除非你确认 channel 不能满足你的需求，那么你可以考虑使用我们这里列举出来的各种队列。

channel 可以理解看做是一个有界的并发阻塞队列。所以当你遇到以下场景的时候，你可以考虑这里的队列：
- 你无法预估 channel 的容量。即你在 make 的时候，不知道应该设置多大的 buffer

### 无界队列与 OOM
绝大多数情况下，我们建议你使用有界队列，并且队列的容量不应该设置得很大。在逼不得已的情况下，如果你要使用无界队列，那么你需要小心一点